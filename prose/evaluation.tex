\section{Evaluation}
\label{sec:prose:evaluation}
Our evaluation of PROSE aims to answer two classes of questions: its \emph{applicability} and its \emph{performance}.
Applicability questions concern (a) our generalization of prior work in PBE
in terms of inductive specifications and witness functions; (b) generality of our library of witness functions;
(c) engineering usability of PROSE.
Performance questions concern the running time of synthesizers generated by PROSE, and the comparison of
PROSE to general-purpose non-inductive synthesizers, such as SyGuS~\cite{sygus}.

\subsection{Case Studies}
\label{sec:prose:evaluation:casestudies}
\Cref{tbl:prose:casestudies} summarizes our case studies: the prior works in inductive synthesis over numerous different
applications that we studied for evaluation of PROSE.
Of the \ref*{case:total} inductive synthesis tools we studied, \ref*{case:totaldc} can be cast as a special case of the
deductive search algorithm
methodology, which we verified by manually formulating corresponding witness functions for their algorithms.
In the other \pgfmathparse{int(\getrefnumber{case:total}-\getrefnumber{case:totaldc})}\pgfmathresult~tools, the
application domain is inductive synthesis, and our problem definition covers their application, but the original
technique is not an instance of deductive search: namely, it is enumerative
search~\cite{transit:protocols,magichaskeller} or constraint solving~\cite{quicksilver}.

\begin{table}[p!]
    \centering
    \newcounter{casenum}
    \setcounter{casenum}{-1}
    \begin{tabular}{>{\refstepcounter{casenum}}llcccc}
        \toprule
        \textbf{Project} & \textbf{Domain} & \textbf{Ded.} & \textbf{Impl.} & $\bm{\constraint}$ & $\bm{\spec'}$ \\
        \midrule
        \citet{flashfill} & String transformation & \yesmark & \yesmark & = & = \\
        \citet{flashextract} & Text extraction & \yesmark & \yesmark & $\sqsupset$ & $\sqsupset$ \\
        \citet{flashnormalize} & Text normalization & \yesmark & \yesmark & = & soft \\
        \citet{flashrelate} & Table normalization & \yesmark & \yesmark & = & = \\
        \citet{vldb12:semantic} & Semantic text editing & \yesmark & \nomark & = & = \\
        \citet{harris2011spreadsheet} & Table transformation & \yesmark & \nomark & = & = \\
        \citet{singh2012synthesizing} & Number transformation & \yesmark & \nomark & = & = \\
        \citet{andersen:procedural} & Algebra education & \yesmark & \nomark & trace & = \\
        \citet{lau:smartedit} & Editor scripting & \yesmark & \nomark & trace & = \\
        \citet{pldi15:swarat} & ADT transformation & \yesmark & \nomark & = & = \\
        \citet{pldi15:osera} & ADT transformation & \yesmark & \nomark & = & = \\
        \label{case:totaldc}\citet{miller:colorful} & Editor scripting & \yesmark & \nomark & = & = \\
        \citet{transit:protocols} & Concurrent protocols & \nomark & \nomark & trace & N/A \\
        \citet{magichaskeller} & Haskell programs & \nomark & \nomark & = & N/A \\
        \label{case:total}\citet{quicksilver} & Relational queries & \nomark & \nomark & = & N/A \\
        \midrule
        \label{case:totalwithfw}\textsf{WebExtract} & Web data extraction & \yesmark & \yesmark & $\sqsupset$ &
            $\sqsupset$ \\
        \bottomrule
    \end{tabular}
    \todoinline{Add more case studies from 2016-2017.}
    \uwsinglespace
    \caption{Case studies of PROSE: prior works in inductive program synthesis.
        ``Ded.'' means ``Is it an instance of the deductive methodology?'',
        ``Impl.'' means ``Have we (re-)implemented it on top of PROSE?'', $\constraint$ is a top-level constraint kind,
        $\spec'$ lists notable intermediate constraint kinds (for the deductive techniques only).}
    \label{tbl:prose:casestudies}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{1}{c}{\multirow{2}{*}{\textbf{Project}}} & \multicolumn{2}{c}{\textbf{LOC}} & \multicolumn{2}{c}{\textbf{Development time}} \\
        \cmidrule{2-3}  \cmidrule{4-5}
        & Original & PROSE & Original & PROSE \\
        \midrule
        \citet{flashfill} & 12K & 3K & 9 months & 1 month \\
        \citet{flashextract} & 7K & 4K & 8 months & 1 month \\
        \citet{flashnormalize} & 17K & 2K & 7 months & 2 months \\
        \citet{flashrelate} & 5K & 2K & 8 months & 1 month \\
        \textsf{WebExtract} & --- & 2.5K & --- & 1.5 months \\
        \bottomrule
    \end{tabular}
    \caption{Development data on the (re-)implemented projects.}
    \label{tbl:prose:reimplementation}
\end{table}

Our industrial collaborators reimplemented 4 existing systems
and created a new system \textsf{WebExtract} for synthesis of CSS selectors for extraction of webpage data by example;
it reuses portions of existing languages as external submodules.
We present data on these development efforts in \Cref{tbl:prose:reimplementation}.

\paragraph{Q1: How motivated is our generalization of inductive specification?}
Input-output examples is the most popular specification kind, observed in 12/\ref*{case:total} projects.
However, 3 projects require \emph{program traces} as their top-level specification, and 2 projects (1 prior) require
\emph{subsequences of program output}.
Boolean connectives such as $\vee$ and $\neg$ are omnipresent in subproblems across all \ref*{case:totaldc} projects
implemented using deductive search.

\paragraph{Q2: How applicable is our generic operator library?}
Most common operators across our case studies are string processing functions, due to the most popular domain being data
manipulation (11/\ref*{case:totalwithfw} projects).
Almost all projects include some version of learning conditional operators (equivalent to that of FlashFill).
List processing operators (e.g. $\mathsf{Map}$, $\mathsf{Filter}$) appear in 9/\ref*{case:totalwithfw} projects, often
without explicit realization by the original authors (for example, the awkwardly defined \textsf{Loop} operator in
FlashFill is actually a combination of \textsf{Concatenate} and \textsf{Map}).
\citet{pldi15:swarat} define an extensive library of synthesis strategies for list-processing operators in the
$\lambda^2$ project.
These synthesis strategies are isomorphic to FlashExtract witness functions; both approaches can be cast as instances of
deductive search (see \Cref{ch:related} for detailed comparison).

\paragraph{Q3: How usable is PROSE?}
\Cref{tbl:prose:reimplementation} presents some development stats on the projects that were reimplemented.
In all cases, PROSE-based implementations were shorter, cleaner, more stable and extensible.
The reason is that with PROSE, our collaborators did not concern themselves with tricky details of synthesis
algorithms, since they were implemented once and for all, as in \Cref{sec:prose:algorithm}.
Instead, they focused only on domain-specific witness functions, for which design, implementation, and maintenance are
much easier.
Notably, in case of the FlashRelate~\cite{flashrelate} reimplementation and \textsf{WebExtract}, our collaborators did
not have any experience in program synthesis.

The development time in \Cref{tbl:prose:reimplementation} includes the time required for an implementation to mature
(i.e. cover the required use cases), which required multiple experiments with DSLs.
With PROSE, various improvements over DSLs were possible on a daily basis.
PROSE also allowed our collaborators to discover optimizations not present in the original implementations.
We share some anecdotes of PROSE simplifying synthesizer development below.

\begin{scenario}
    One of the main algorithmic insights of FlashFill is synthesis of $\mathsf{Concat}(e_1, \dots, e_k)$ expressions
    using \emph{DAG program sharing}.
    A DAG over the positions in the output string $s$ is maintained, each edge $s[i:j]$ annotated with a
    set of programs that output this substring on a given state $\state$.
    Most of the formalism in the paper and code in their implementation is spent on describing and performing operations
    on such a DAG.
    In PROSE, the same grammar symbol is instead defined through a recursive binary operator: $f := e \,|\,
    \mathsf{Concat}(e, f)$.
    The witness function for $e$ in \textsf{Concat} constructs $\spec'$ as a disjunction of all prefixes of
    the output string in $\spec$.
    The property for $f$ is conditional on $e$ and simply selects the suffix of the output string after the given prefix
    $\semantics{e}{\state}$.
    Since PROSE caches the results of learning calls $\langle f, \spec \rangle$ for same $\spec$s, the tree of
    recursive $\mathsf{Learn}(f, \spec)$ calls becomes a DAG.
    This is \emph{the same DAG} as in FlashFill -- but with PROSE, it arises implicitly and at no cost.
    Moreover, it becomes obvious now that DAG sharing happens for any foldable operator, e.g. \textsf{ITE}, $\wedge$,
    $\vee$, sequential statements.
    \todoinline{Illustration of the \texttt{Concat} DAG.}
\end{scenario}

\begin{scenario}
    During reimplementation of FlashFill, a new operator was added to its substring extraction logic: \emph{relative
    positioning},
    which defines the right boundary of a substring depending on the value of its left boundary.
    For example, it enables extracting substrings as in ``ten characters after the first digit''.
    This extension simply involved adding three \texttt{let} rules in the DSL, which (a) define the left boundary
    position using existing operators; (b) cut the suffix starting from that position; (c) define the right boundary in
    the suffix.
    This extension was inspired by some practically useful tasks that FlashFill fails to handle.
    While such an extension in the original FlashFill implementation would consume a couple of weeks, in PROSE it
    took only a few minutes.
\end{scenario}

\begin{scenario}
    A CSS selector is a function $\mathsf{Document} \to \mathsf{Set}\langle \mathsf{DOMNode}\rangle$.
    It is a path specification for a DOM node where each element in the path is a predicate on the corresponding
    ancestor (i.e.  the ancestor's tag or its class), and each edge in the path descends to all children of the
    preceding element that satisfy a certain property~\cite{css3selectors}.

    A spec synthesis of CSS selectors is a subset of selected DOM nodes.
    Using an enumerative search for this problem induces an exponential blowup: it starts with an input state (an HTML
    document) and iteratively constructs all possible CSS selectors.
    Since they may select arbitrary subsets of the DOM tree, the resulting search is infeasible.

    In contrast, a deductive approach starts with an \emph{output} (a set of nodes), and deduces examples for the
    intermediate subexpressions (prefixes of the desired CSS selector).
    This process follows the DOM tree \emph{upwards}, instead of \emph{downwards}, and therefore is by construction
    finite.
    Moreover, the number of deduction steps is bounded by the tree depth.
\end{scenario}

\subsection{Experiments}
\label{sec:prose:evaluation:experiments}
